# 하노이탑 구현 및 시간복잡도 계산

<hr>

### 순환을 이용한 하노이탑 알고리즘

```c
#include<stdio.h>
void hanoi_tower(int n, char from, char tmp, char to)
{
if (n == 1)
printf("원판 1을 %c 에서 %c 로 옯긴다.\n", from, to);
else
{

hanoi_tower(n - 1, from, to, tmp);
printf("원판 %d을 %c 에서 %c 로 옮긴다.\n", n, from, to);
hanoi_tower(n - 1, tmp, from, to);
}
}

int main()
{
int N = 0;
scanf("%d", &N);
hanoi_tower(N, 'A', 'B', 'C');

return 0;
}

```
<hr>

### 반복을 이용한 하노이탑 알고리즘
```c
#include<stdio.h>
#define MAX 100

int stack[MAX];
int top = 0;

void push(int Input)
{
stack[top++] = Input;
}
int pop()
{
if (top > 0)
{
return stack[--top];
}
}


int main()
{
int from;
int temp;
int to;
int N;
int next = 1;
scanf("%d", &N);

push('A');
push('B');
push('C');
push(N);
while (1)
{
if (top == 0)
break;
N = pop();
to = pop();
temp = pop();
from = pop();
if (N == 1)
{
printf("원판 1 을 %c 에서 %c 로 옮긴다.\n", from, to);
next = 0;
continue;
}
else
{
if (next == 0)
{
printf("원판 %d 을 %c 에서 %c 로 옮긴다.\n", N, from, to);
next = 1;
push(temp);
push(from);
push(to);
push(N - 1);
continue;
}

push(from);
push(temp);
push(to);
push(N);

if (next == 1)
{
push(from);
push(to);
push(temp);
push(N - 1);
}
}
}
}
```

<hr>

### 하노이탑 알고리즘 시간복잡도 분석

__순환을 이용한 알고리즘__ 의 경우 원판의 개수 가 n개 일 때 hanoi_tower(int n, char from, char tmp, char to) 이 실행되면 2개의 hanoi_tower(int n-1, char from, char tmp, char to) 이 실행되고 이는 또 각각 2개의 hanoi_tower(int n-2, char from, char tmp, char to) 를 실행시킨다.
이를 식으로 나타내면 
>hanoi(n)
= 2 * hanoi(n - 1) + 1 <br>
= 4 * hanoi(n - 2) + 3<br>
= 8 * hanoi(n - 3) + 7<br>
= 16 * hanoi(n - 4) + 15<br>
...<br>
= 2^(n-1)hanoi(n - (n - 1)) + (2^(n-1) - 1)<br>
= 2^n - 1

따라서 순환을 이용한 하노이탑 알고리즘은 피보나치함수와 같은 시간복잡도 `O(2^n)`을 가진다.<br><br>

**반복을 이용한 알고리즘** 의 경우 재귀함수를 사용하지는 않지만 while() 문이 한번 반복할 때 마다 원판이 한번 움직이므로 원판을 모두 움직이기 위해서는 2^n-1 만큼의 반복이 필요하다. 따라서 반복을 이용한 알고리즘 역시 `O(2^n)`의 시간복잡도를 가진다.
<br><br>
두 알고리즘의 시간복잡도가 같기때문에 성능에서의 차이는 없으나 코드의 가독성이나 작성하는데에 있어서 **순환을 이용한 알고리즘**이 더 나은것으로 생각된다.

<hr>